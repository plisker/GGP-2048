\documentclass[12pt]{article}
\usepackage{common}
\usepackage{hyperref}
\hypersetup{colorlinks,urlcolor=blue}
\setlength{\parindent}{0cm}
\title{General game-playing applied to 2048}
\author{Paul Lisker and Ahmed Ahmed}
\begin{document}
\maketitle{}

%\section{Topic Statement}
%The purpose of this project is to create a General Game Playing agent for the domain of games similar to and including \href{https://gabrielecirulli.github.io/2048/}{2048}. In other words, this agent should be able to successfully play a game on which it has not been trained.

\section{Introduction}
General Game Playing (GGP) is a subfield of Artificial Intelligence that seeks to develop agents that are capable of playing many games rather than being tailored and limited to particular game. GGP has been a popular subject of AI research, particularly over the past decade. The goal of GGP is to create programs that are capable of successfully playing more than one game successfully. As such, a successful GGP agent will not have algorithms tailored to a particular game, but rather generalized algorithms that can be successful when applied to various different games (though occasionally of the same domain---that is, games that are similar in nature). For an illustrative example on the difference between a regular game playing agent and a GGP agent, we can look at IBM's famous Deep Blue computer. This computer ran an AI program that was tailored to the goal of winning a game of chess; however, this program would have been unusable for other games. On the other end of the spectrum, successful GGP programs can play---albeit perhaps less effectively as a dedicated algorithm---more games than just one, or play games that would otherwise be intractable for specialized algorithms.\\

The requirements of General Game Playing, then, necessitate the use of algorithms that are not domain-specific. in other words, it must use algorithms that can operate with a broad spectrum of games without being dependent on shared rules between said games. Among this class of algorithms is the notable GGP algorithm of Monte Carlo Tree Search (MCTS), a class of algorithms for finding optimal choices in a decision space by taking random sample simulations and building a search tree according to their results. We explore this algorithm with more in Section 4.\\

\section{Background and Related Work}

\subsection{Introduction to 2048}
\href{https://gabrielecirulli.github.io/2048/}{2048} is a single-player puzzle game developed by Gabrielle Cirulli that was a viral hit in 2014 \cite{twentyfortyeight}. This game consisted of a $4\times4$ grid in which each cell is either empty or contains a tile with a number that is a power of 2. In each move, the player chooses a direction in which to slide all the tiles with the goal of having tiles of the same number collide to merge and create a tile of their sum. After each move, a new tile is spawned randomly in any empty cell. The game's goal is to reach the eponymous tile; it continues until (1) there are no more available moves---no more merges possible or open tiles---or (2) the 2048 tiles is reaches, though at that point the user is given the option to continue beyond to form higher tiles.\\

\subsection{Monte Carlo Tree Search}
Add here

\subsection{Taken from introduction, incorporate here}
In this project, we apply MCTS to the domain of games including the popular puzzle game 2048, analyze its performance, and compare it to other successful AI approaches.\\


Therefore, our first goal is to develop a program that can win the game. In good competitive spirit, it naturally follows the secondary goal of maximizing scores in order to compete with the better 2048 programs that have been previously published. Subsequently, we analyze the performance of our implementation with and without the use of game-specific heuristics. Finally, we also analyze the flexibility afforded by our use of GGP techniques, by applying our implementation to an expanded class of similar games we call \textit{generalized-2048} created by allowing variation in some of the rules of standard 2048. \\

The specific algorithm we chose to implement is Upper Confidence Bounds for Trees (UCT), a common flavor of Monte Carlo Tree Search (MCTS). There has been a boom in research on MCTS algorithms in the past decade after MCTS AI players were successful at the classical Chinese game and universal challenge for AI game-playing, Go. MCTS provides an alternative to the traditional approach to combinatorial games, minimax algorithms, especially in games of nontrivial size for which no reliable heuristic has been developed situations in which minimax often fails. However, in cases where reliable domain-specific heuristics have been developed - as is the case for 2048 - either MCTS or minimax may be applicable.\\

MCTS is essentially a class of techniques for traversing the game-trees. Such game-trees are an especially convenient model for \textit{combinatorial games} such as 2048 - that is, sequential, discrete, full-information games. Therefore, this project most directly draws off of the concepts of uninformed and heuristic search that we explored earlier in this course. Additionally, MCTS does have a Monte Carlo portion - that is, it uses sampling in order to approximately inform its search. This concept of using of sampling methods to find approximate answers to intractable problems was explored in this course in the context of particle filters in Bayes Nets.\\

\subsection{Published solutions}
\noindent As the game went viral in 2014, the AI game-playing community went to work at publishing several automated 2048 players. Most approaches that the authors are aware of have been minimax implementations, so most focused on developing useful heuristics and optimizing for faster run times in order to increase the depth of their minimax searches within reasonable time. Our implementation distinguishes itself from these solutions, in that it doesn't use minimax at all, instead using MCTS as our primary method.

Though the authors XXX applied MCTS with great success to the combinatoric puzzle game Sudoku and XXXX.\\

\medskip

\section{Problem Specification}
In this project, we aim to build an artificial intelligence program that can play well at an arbitrary game in the class of games, \textbf{ generalized-2048}. We define generalized-2048 as the set of games with rules equivalent to those of standard 2048, except: x y z.\\
\begin{enumerate}
\item It may have an arbitrary board size $n \times m$ instead of just the $4 \times 4$ board in standard 2048.
\item It may have an arbitrary score function $R$, instead of the standard 2048 instead of the cumulative score of merged tile values. 
\end{enumerate} 

\medskip

\section{Approach}
% A clear specification of the algorithm(s) you used and a description
% of the main data structures in the implementation. Include a
% discussion of any details of the algorithm that were not in the
% published paper(s) that formed the basis of your implementation. A
% reader should be able to reconstruct and verify your work from reading
% your paper.
\begin{itemize}
\item Introduce our approach: general game playing + lessen the generality
\item Explain how this allows us to expand our domain to larger class of games 
\item (AUTHORS) showed that the class of 2048 games with only the first generalization are NP-complete (SOURCE).
\end{itemize}
\begin{algorithm}
  \begin{algorithmic}
    \Procedure{MyAlgorithm}{$b$}
    \State{$a \gets 10$}
    \EndProcedure{}
  \end{algorithmic}
  \caption{Here is the algorithm.}
\end{algorithm}

\medskip

\section{Experiments}
Analysis, evaluation, and critique of the algorithm and your
implementation. Include a description of the testing data you used and
a discussion of examples that illustrate major features of your
system. Testing is a critical part of system construction, and the
scope of your testing will be an important component in our
evaluation. Discuss what you learned from the implementation.

\begin{table}
  \centering
  \begin{tabular}{lll}
    \toprule
    & Score  & Variance\\
    \midrule
    Random & 1103.2 & \\
%     MCTS alone & 8457.7 & 2.0 e$^3 $\\
    MCTS with heuristic & XXX & $5.6$ e$^3$\\
    Heuristic alone & XXX & ZZZ\\
    \bottomrule
  \end{tabular}
  \caption{A performed better than B and C at standard 2048.}
\end{table}


\subsection{Results}
Here we compare 

\medskip

\section{Discussion}
Summary of approach and results. Major takeaways? Things you could improve in future work?

\appendix

\section{System Description}
 Appendix 1 Ð A clear description of how to use your system and how to generate the output you discussed in the write-up. \emph{The teaching staff must be able to run your system.}

\section{Group Makeup}
 Appendix 2 Ð Ahmed Ahmed and Paul Lisker


\bibliography{lisker_ahmed_ggp}
\bibliographystyle{plain} 


\end{document}
